## Code7: early Termination

Can you learn when enough is enough.

If the code runs in "eras" of, say, 100 evals per era, how to test in era X that there has been no future improvement expected?

- Type1: just compare median performance scores (design challenge: what performance score to use?)
- Type2: Use effect size tests to just if the performance scores are not changing (design challenge: what threshold should you use for a "small effect"?)
- Type2: Use effect size + hypothesis test (bootstrap) to judge no improvement (design challenge: how many bootstraps to use?)

For DE and MWS and SA, code up the Type1,Type2, Type3 comparison operators and use them to:

+ Find the final era computed by DE, MWS, SA (with early termination)
+ Compute the cdom _loss_ numbers between era0 the final era
     + Important implementation note: repeat the above with 20 different baseline populations. For each baseline, run DE,MWS,SA.

     Apply the above for [DTLZ7](http://e-collection.library.ethz.ch/eserv/eth:24696/eth-24696-01.pdf)
     with 2 objectives 10 decisions.

ALso comment on the runtime implications (if any) of using  bootstrap.


### Abstract
So far we have always allowed the optimizers to run for certain number of eras. But in many cases the solutions generated by these optimizers don't change 
after a certain number of eras. The optimizer can be early terminated when it reaches this stage and hence we can save a lot of computing power.

Also Every model produces different objectives and decisions Each model, when run with different optimizers. To identify the best optimizer, 
for which the model is being reduced or expanded to the target minimum or maximum, can be found by comparing the results of all the possible combinations.
This coding project works with the DTLZ7 model, on which Simulated Annealing, Max Walk Sat and Differential Evolution are performed. 
These results are compared based on the type comparators to provide a ranked output of the optimizers for this particular model.

### Introduction
In this study we try to find out which out of Differential Evolution , Simulated Annealing 
and MaxWalkSat is best to optimize DTLZ7 with 2 objectives and 10 decisions. To study these optimizers we use Type 1 , Type 2 and Type 3 comparison operators . 
To optimize a multiple objective model. different optimizers can be used . These optimizers may or may not find the best 
candidate solution . When we are using stochastic search to optimize a problem , we need some kind of statistical machinery to figure out whether or not the given optimizer is 
the best for the given problem being optimized. In this study our aim is to apply these comparison operators and find the best optimizer for a problem. These are the different 
comparison operators we use in this study.

### Models and Optimizers

**Simulated Annealing**

This optimizer avoids the settling of the model objective values at local minima by jumping to suboptimal points while the temperature
 is still low. The number of iterations is initially fixated and the temperature is set at zero and increased every iteration.
 An initial model object instance is created which is considered as the best candidate with best objectives. 
 For each iteration, the model is newly instantiated. The objectives of the generated candidate is compared with the best, 
 and if proven better, updates the best to hold the values of itself. A random value is generated and checked if it is greater 
 than the probability function, which determines if the candidate should remain where it is or take a risk of jumping to a worse solution. 
 The function takes the parameters of the old and new objective values of candidates and the temperature. The old value is copied to the 
 new value if the probability function returns true, or else, remains at the new candidate. This repeats for all iterations or until 
 it has lives remaining. The number of lives to be added or subtracted, and the candidate comparisons are performed by type 1 
 comparisons, which are described later in detail.

**Max Walk Sat**

Max Walk Sat is a non-parametric stochastic algorithm, which deals with analyzing the landscape of the data. 
Similar to Simulated Annealing, it prevents local minima by making jumps to random worse points. If the spread of the data is bumpy, 
this optimizer works most efficiently. It starts off by setting a maximum number of tries and changes, defining the number of iterations for 
which the optimizers runs (without early termination). Creation of object instance and shuffling it with the best instance to finally 
store the best energy seen so far occurs similar to SA. In addition to this, a probability is set and is checked if the generated random 
value is lesser. If so, the optimizer is still at it's early stages and can afford to jump to worse points to escape local minima. 
Thus, a decision is picked at random and changed. Else, the random decision is changed to obtain the best energy. The optimizer provides 
an output of the best combination of decisions and objectives.

**Differential Evolution**

This optimizer works in an intelligent manner by generating frontiers and ruling out bad decisions by binary or continuous domination 
mechanisms. It assumes that the final era or frontier is the best if it is dominated by at least one but worse of none of the previous values. 
It additionally takes an input of probability of crossover and extrapolate amount. The former decides the probability at which the other 
candidates should be extrapolated and the latter defines the ratio of extrapolation. Initially, a frontier of random candidates is generated 
and is further entered into the iteration of repeats, to keep randomly picking any other three candidates besides itself for mutation and 
extrapolation, if the generated random value is within the probability of crossover. This finally yields the final frontier, which comprises 
of the best candidates with least objectives, in the case of minimization problem.

**Scott-knott**

The Scott & Knott method make use of a cluster analysis algorithm, where, starting from the whole group of observed mean effects, it divides, and keep dividing the sub-groups in such a way that the intersection of any two groups formed in that manner is empty [3]

**DTLZ7** 

DTLZ7 [1] is one of the models in the DTLZ class of models, which were designed to stress test optimizers. In this particular experiment I have used DTLZ7 with 10 decision variables and 2 objective functions. In later experiments, the DTLZ model as well as the number of variables and objective functions has been varied.


### Comparators
**Type1 Comparator**
Type 1 comparator is used to check if one solution in the population is better than another solution
The cumulative sum of each objective is used as the performance score.

**Type2 Comparator** [2]

Type2 operator is used to compare the solutions of two eras. A12 is used to calculate the difference between eras. This comparator is used to check if there is Small effect which can be used to early terminate an optimizer.
The A12 statistics measures the probability that running algorithm X yields higher values than running another algorithm Y.According to Vargha and Delaney, 
a small, medium, large difference between two populations is: 

large if a12 is over 71%;
medium if a12 is over 64%;
small if a12 is 56%, or less.

Here we consider a small effect so we set threshold to 0.56.

**Type3 Comparator**

Type3 operator is used to compare the solutions of the final eras of multiple optimizers. This comparator is used to check which optimizer produces the best solution for the given model. 
The rdivdemo program creates graphs which show the median, the inter quartile range and the 25 %ile , 50 %ile amd 70 % ile values .




### References
[1][http://e-collection.library.ethz.ch/eserv/eth:24696/eth-24696-01.pdf](http://e-collection.library.ethz.ch/eserv/eth:24696/eth-24696-01.pdf)
[2][https://github.com/txt/ase16/blob/master/src/stats.py](https://github.com/txt/ase16/blob/master/src/stats.py) 
[3][https://github.com/txt/ase16/blob/master/doc/perform.md](https://github.com/txt/ase16/blob/master/doc/perform.md) 
[4][https://rdrr.io/cran/ScottKnott/man/ScottKnott-package.html](https://rdrr.io/cran/ScottKnott/man/ScottKnott-package.html)